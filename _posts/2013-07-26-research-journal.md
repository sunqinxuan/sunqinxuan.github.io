---
title: '【研究工作记录】2013-07'
date: 2013-07-26
permalink: /posts/research-journal-2013-07/
tags:
  - research journal
---

research journal, 2014.4.

## 基本任务目标

在已知两幅（多幅）点云数据以及之间变换关系的前提下（或者说在已知已匹配点云的前提下），完成点云的拼接，以及重合区域点的融合处理。

## 实现平台：

Visual Studio 2010，PCL

## 进度安排

1、学习关于PCL所提供的有关点云处理的接口以及编程方法。

2、查阅文献，重点了解点云地图重建或者三维物体的点云重建过程中，在完成每帧之间点云的匹配后，用什么方法来实现匹配后点云的拼接，以及拼接的过程中如何处理重叠区域给重建工作带来的影响。

3、利用PCL提供的接口编程实现基础任务目标，并进行一些力所能及的优化工作。

## 主要工作内容

### 关于点云拼接的调研学习

点云拼接主要用于增量式点云地图的创建和三维物体重构中，其中若需要进行三维物体重构还涉及到一个表面重建的问题，这是在进行重合区域的对应点融合之后的下一个步骤。所以在搜索文献的过程中，我主要搜索了这两个领域相关的资料，由于对于每一篇文献来说，它所说明内容的侧重点有所不同，很大一部分都在重点讲述点云匹配的问题，也有一部分的重点放在表面重建上，而点云拼接和融合作为这两个过程的中间步骤，在很多文献中是作为大致带过的内容。参考文献[1]-[3]是在一些简略带过的文献的参考次中找到的几篇对这一部分有详细论述的文章。

文献[1]在点云匹配之后的融合处理中提出了一种加权平均的算法，而其中的权重是根据点云中某点到邻近边界的距离算出来的，这样一来，即使在匹配不准确的时候也能保证重建表面的平滑性，避免类似“断层”的情况出现，如下图所示（其中，（a）为直接平均的结果，（b）为加权平均的结果）。我认为这样的一种思路主要面向的应该是物体表面重建，因为表面重建的时候对重建表面平滑性的要求应该算是一个比较重要的指标，如果在点云中对应点融合的时候若出现了断层的情况，那后面进行表面重建时可能会出现一定的问题。

![img](https://sunqinxuan.github.io/images/posts-research-journal-2013-07-img1.png)

文献[2]所论述的侧重点是融合和重建（Integration and reconstruction），几乎略过了点云匹配这一部分的内容，对融合过程有了一个更为详细的说明。其中提到的融合算法包括三个步骤：重合区域检测，对应点检测，以及对应点融合。

首先是重合区域的检测，如果给定的两个点云P和Q，对于P中的某一点pi，在Q中搜索其最邻近点qi，若pi与qi之间的距离在某一阈值之内，则认为pi与qi分别在P与Q的重合区域内，而对于与最邻近点的距离在阈值之外的那些点来说，认为其在非重合区域中，这样一来，在遍历过点云中所有点之后便完成了两个点云的重合区域的检测（Overlapping area detection）。

其次是对应点对的检测，其实在重合区域检测的过程中pi与qi便可以看作是一对对应点，只是文中考虑到为了避免一些匹配误差和扫描噪声的干扰，提出了将重合区域的点沿其法线方法移动一段距离，这样就可以在不改变重合区域面积以及表面拓扑结构的前提下，更准确地得到对应点的信息，如下图。但这种方法在实现之间需要得到一些几何信息，比如法向量，表面曲率，领域信息等等，文中提到可以通过构建三角网格来实现这个目的。

![img](https://sunqinxuan.github.io/images/posts-research-journal-2013-07-img2.png)

最后是对应点的融合，与文献[1]类似，这里也运用了一种加权平均的算法，不同的是这里的权重是根据点的置信率来计算的，而点的置信率则是根据和该点方向信息有关的一个包含角来得到的（这里角的具体位置我没太理解）。

而文献[3]是文献[2]的作者发的另外一篇文章，思路与[2]中所述基本相同，并在此基础上引入了一个k均值聚类的想法，用于更精确的进行对应点对的识别，并给出了更多的实验结果进行说明。

### PCL中相关模块与类的学习和使用

出于任务完成的考虑，我主要对以下类进行了一些学习和了解：

- 最基础的，pcl::PointT和pcl::PointCloud。在点云的表示中充分利用了C++类模板的形式，方便表示多种类型的点构成的点云数据。

- 可视化相关，pcl::visualization，实现点云的可视化操作，方便查看与验证实验结果。
- Kd-tree，pcl::KdTreeFLANN，作为一种方便又快速的空间索引方法，可以用于重合区域识别时的邻近点搜索中，来加快搜索的速度和效率。
- 滤波，进行了简单的了解，在减小数据量或去除干扰的时候或许可以用到。
- 深度图像的创建及其可视化，pcl::RangeImage。因为深度图像与点云之间存在一个相互转化的关系，所以在点云数据的存储时可以考虑用深度图像的方式，来提高存取的速度。
- 点云匹配与点云曲面重建，简单了解。

### 程序框架构思与程序编写

在具体实现中，对于cloud_filtered中的每一点，运用kd-tree的方法在cloud_search_filtered中搜索其最邻近点，并判断该点与其最邻近点之间的距离平方是否在一个给定阈值之内，若是则将其判定为重合区域中的点，并将其与其最邻近点进行一次加权平均的融合（权重暂时固定为0.5），生成融合后的点写入点云cloud_overlapping中，而那些没有找到对应点的点写入cloud_non_overlapping中，方便可视化时查看最终效果。

## 遇到问题及思路

### 实时性

对于两个已经过滤波的点云来说，数据量分别为25万左右，cloud_search_filtered中的所有点都遍历一遍，用kd-tree在cloud_filtered中搜索邻近点所耗时间大概为3.5s左右。如果数据量再小一些或者不需遍历cloud_search_filtered中所有的点进行搜索，一次处理的时间或许能达到实时性要求。但增量式生成地图的过程中，搜索点云的数据量是在不断增加的，这样一来会有搜索时间越来越长的问题。

### 对应点选取

程序中所完成的严格上来说只能重叠区域的识别，并没有进行对应点的检测，所以在进行融合时，对应点并没有达到一一对应的关系，而是一对多的关系，这样一来在进行融合的时候会出现融合后的点云分布不均的情况，如下图所示。

![img](https://sunqinxuan.github.io/images/posts-research-journal-2013-07-img3.png)

此时若调整权重系数可使以上问题得到一些改善，如下图所示是将权重调整为0.8与0.2，即减小被搜索点云中点的权重后的结果，基本可以达到与原点云分布相当的程度。但若要从根本上解决此问题，需要判断点与点之间更准确的对应关系。在文献[2]与文献[3]中是采用将点沿其法向移动，然后再用类似聚类的方法，来检测更准确的对应关系。只是这样的方法需要在已知一些几何信息的前提下，也就需要加入额外的计算，需要考虑其对实时性的影响。

![img](https://sunqinxuan.github.io/images/posts-research-journal-2013-07-img4.png)

## 参考文献

- [1] C. Dorai, A. K. Jain. Registration and Integration of Multiple Object Views for 3D Model Construction[J]. Pattern Analysis and Machine Intelligence, 1998, 20(1): 83 – 89.

- [2] H. Zhou, Y. Liu. Incremental point-based integration of registered multiple range images[J]. Industrial Electronics Society, 2005, 23: 6-10.

- [3] H. Zhou, Y. Liu. Accurate integration of multi-view range images using k-means clustering[J]. Pattern Recognition, 2008, 41(1): 152–175.



### 特征点的提取与匹配

1.角点检测：FAST（Features from Accelerated Segment Test）使用直径为3、4个像素的圆周作为检测模板；如果圆周上存在n个连续像素，它们的亮度均高于候选像素亮度Ip和阈值t之和，或，它们的亮度均低于Ip- t，则模板中心对应像素为角点。

2.特征描述符：BRIEF（Binary Robust Independent Elementary Features），选择n个二值测试的像素对，BRIEF描述符是n位的比特串。

3.处理时间统计（特征点数量：~1500/帧）

|                 | 处理时间 |
| :-------------: | :------: |
|  Fast角点检测   |   10ms   |
| Brief描述符生成 |   10ms   |
|   特征点匹配    |   60ms   |

### 粗匹配

将特征点投影到三维空间，用Ransac算法完成粗匹配，匹配时间约240ms。

1. 在匹配好的点对中随机选出三个点对，确定一个变换RT。
2. 将RT作用于所有匹配点对，筛选出符合RT变换的点对（内点），记内点数count。
3. 循环执行1~2，直到内点数count到达一个阈值，或者迭代次数超过一个阈值，停止迭代。
4. 记此时的变换RT为粗匹配的结果。

| **第n次匹配** | **ICP时间（ms）** |
| :-----------: | :---------------: |
|       1       |        294        |
|       2       |        291        |
|       3       |        246        |
|       4       |        251        |
|       5       |        215        |
|       6       |        230        |
|       7       |        252        |
|       8       |        259        |
|       9       |        246        |

![img](https://sunqinxuan.github.io/images/posts-research-journal-2014-04-img1.png)
![img](https://sunqinxuan.github.io/images/posts-research-journal-2014-04-img2.png)

## 后期工作思路

- 提高匹配过程的鲁棒性

- 在用特征点粗匹配失效时提供备选策略

  - 在粗匹配的实现中考虑图像中的其它信息，如颜色、纹理等。

  - 加入学习机制，建立地图的高层描述。

