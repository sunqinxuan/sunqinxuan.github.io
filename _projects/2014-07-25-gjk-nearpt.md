---
title: "基于GJK算法的物体最近距离计算方法"
collection: projects
type: "Project"
permalink: /projects/2014-07-25-gjk-nearpt
venue: "Nankai University"
date: 2014-07-25
location: "Tianjin, China"
---

基于GJK算法的物体最近距离计算方法

## 基本算法原理

### 用GJK算法估计最近距离 

GJK（Gilbert-Johnson-Keerthi）算法是一种碰撞检测算法，用GJK算法来计算两个凸多边形之间的最短距离实际上就是它们之间的明可夫斯基差与原点的距离，若其明可夫斯基包含原点，则表示这两个凸多边形相交。

其中，明可夫斯基差实际上就是明可夫斯基和的概念。

假设有两个物体，他们的明可夫斯基和就是物体A上的所有点和物体B上的所有点的和集，即：

$$
A+B=\{a+b|a\in A,b\in B\}
$$

显然如果两个物体都是凸体，则它们的明可夫斯基和也是凸体。而明可夫斯基差就是明可夫斯基和相对于减法的概念。可以表示为：

$$
A-B=\{a-b|a\in A,b\in B\}
$$

如果两个凸多边形没有碰撞，则其明可夫斯基差不包含原点，且此时它们之间的最短距离就是它们的明可夫斯基差形状到原点的最近距离。

### Kd_tree搜索加速

Kd_tree（K_dimension tree）是对数据点在k维空间中划分的一种数据结构。Kd_tree是一种二叉树，每个节点表示的是一个空间范围。它是通过建立数据索引从而进行快速匹配的，因为实际的数据通常会呈现出簇状的聚类形态，通过设计有效的索引结构可以大大加快检索的速度。

在C++中，可以通过对ANN（A Library for Approximate Nearest Neighbor Searching）库函数的调用来直接实现Kd_tree的相关算法。ANN是一个用C++写成的库，支持各种高维最近邻搜索的数据结构和相关算法。

### KNN算法

KNN（k_Nearest Neighbor）分类算法是最简单的机器学习算法之一。该算法是思路是，如果一个样本在特征空间中的k个最邻近的样本中的大多数属于某一个类别，则该样本也属于这个类别。KNN算法中，所选择的邻近样本都是已正确分类的对象。

KNN算法不仅可以用于分类，也可以用于回归。通过找出一个样本的k个最近邻，将这些近邻的属性平均值赋给该样本，就可以得到这个样本的属性。

该算法的一个主要不足是当样本平衡时，如一个类的样本容量远远大于其他类，有可能导致当输入一个新样本时，该样本的k个近邻中这个大容量的类样本会占多数。

### CUDA原理

CUDA（Compute Unified Device Architecture）是显卡厂商NVIDIA推出的运算平台，是一种由NVIDIA推出的通用并行计算架构，可以使GPU能够解决复杂的计算问题。开发人员可以用C语言来为CUDA架构编写程序。

使用显示芯片来进行运算工作，和使用 CPU 相比，主要有几个好处：

1. 显示芯片通常具有更大的内存带宽。例如，NVIDIA 的 GeForce 8800GTX 具有超过 50GB/s 的内存带宽，而目前高阶 CPU 的内存带宽则在 10GB/s 左右。 

2. 显示芯片具有更大量的执行单元。例如 GeForce 8800GTX 具有 128 个 "stream processors"，频率为 1.35GHz。CPU 频率通常较高，但是执行单元的数目则要少得多。 

3. 和高阶 CPU 相比，显卡的价格较为低廉。例如目前一张 GeForce 8800GT 包括 512MB 内存的价格，和一颗 2.4GHz 四核心 CPU 的价格相若。

CUDA代码分为两部分，一部分是host（CPU）上运行，是普通的C代码；另一部分在device（GPU）上运行，是并行代码，称为kernel，由nvcc进行编译。Kernel产生的所有线程成为Grid。在并行部分结束后，程序回到串行部分即到host上运行。

在CUDA中，host和device有不同的内存空间。所以在device上执行kernel时，程序员需要把host memory上的数据传送到分配的device memory上。在device执行完以后，需要把结果从device传送回host，并释放device memory。CUDA runtime system提供了API给程序员做这些事情。


## 算法实现流程

### GJK算法的实现

流程如下图所示。

<img src="https://sunqinxuan.github.io/images/project-2014-07-25-img1.PNG" alt="GJK" style="zoom:50%;" />

### 用ANN实现Kd_tree

假设物体A与B，对于物体B，开辟一片内存空间来存储B中的所有点，并定义一个ANNpointArray类的指针指向这片内存空间，并用物体B中的点来构建Kd_tree结构，存储在ANNkd_tree类中。对于物体A中的每一个点，都赋给ANNpoint类作为一个查询点，通过ANNkd_tree类中的annkSearch函数来对物体B中的点进行搜索，找出一个最近邻点作为物体A中某点的最近点。

找到最近点后用欧式距离的计算公式直接来进行距离的计算，然后通过物体A中每个点对应距离的依次比较来确定最终物体A和B的最近点。

### 点到面距离的实现

采样较为稀疏的物体，在Kd_tree算法的基础上得到的最近点可能与两个物体实际上的最近点相差较远。但对于表面情况比较单一的物体，太密集的采样不但影响效率，而且信息量不大。所以针对这样的情况，提出利用点到面距离在一个三角形确定到三角形外某一点的最近点。

具体实现方法：

假设两个物体A和B，用Kd_tree的算法得到了最近点a和b，在物体B上确定点b所在的三角形（可能不止一个），对于每个三角形找到距离a最近的点，再经过依次的比较得到最近距离对应的那个点即为两个物体的最近点。

如下图所示，茶壶为物体A，圆柱体为物体B，而物体B只有上下底面的圆周才有采样点。

![img](https://sunqinxuan.github.io/images/project-2014-07-25-img2.PNG)

## 算法测试

### GJK

实现速度：~90fps（两个物体的采样点数分别为10000个点和2500个点）。

碰撞检测实现的效果较稳定。

距离的计算也比较准确。

存在问题：

- 最近点的确定。因为GJK算法本身不涉及最近点的确定，它正是由于通过迭代算法避开了对点的遍历，才能获得很高的速度，所以无法从算法本身来确定最近点，而需要运用其它的方法。

- 由于GJK算法只适用于凸多边形或凸多面体，所以在实际应用背景下，可能多数情况都不能直接运行该算法来进行距离的计算，从而涉及到如何将复杂物体分割成多个凸多面体，而这个分割的过程是否能满足实时性和准确性的要求。

### ANN

实现速度：~30fps（两个物体的采样点数都为5000个点）。

最近点搜索的结果较稳定，且因其只是针对点的搜索过程，所以适应性较强，对物体本身的形状没有特殊要求。

存在问题：

- 由于距离是直接用得到的最近点来计算的，所以对于采样点较稀疏的物体来说，得到的最近距离可能并不是两个物体之间的最近距离。

![img](https://sunqinxuan.github.io/images/project-2014-07-25-img3.gif)

## 相关链接

代码：[gjk_nearpt](https://github.com/sunqinxuan/gjk_nearpt)

发明专利：[CN104462764A](https://sunqinxuan.github.io/publication/CN104462764A)